/* $Id:$ 
 * d_square.model 
 * Copyright (C) 2011 Albert Davis
 * Author:   Gennadiy Serdyuk gserdyuk@gserdyuk.com
 *
 *------------------------------------------------------------------
 * i=a*v^2 *signof(v) model.
 * netlist syntax:
 * device:  Axxxx n+ n- mname Area=<area>
 * model:   .model mname A
 * properties - singularity (di/dv=0) at v=0
 */
/* This file is automatically generated. DO NOT EDIT */
#ifndef D_SQUARE_H_INCLUDED
#define D_SQUARE_H_INCLUDED

  enum region_t {REVERSE=-1, UNKNOWN=0, FORWARD=1};
  enum polarity_t {pP = -1, pN = 1};
#include "u_sdp.h"
#include "e_node.h"
#include "e_subckt.h"
#include "e_model.h"
/*--------------------------------------------------------------------------*/
class SDP_BUILT_IN_SQUARE
  :public SDP_CARD{
public:
  explicit SDP_BUILT_IN_SQUARE(const COMMON_COMPONENT* c) : SDP_CARD(c) {init(c);}
  void init(const COMMON_COMPONENT*);
public:
};
/*--------------------------------------------------------------------------*/
class DEV_BUILT_IN_SQUARE;
class TDP_BUILT_IN_SQUARE{
public:
  explicit TDP_BUILT_IN_SQUARE(const DEV_BUILT_IN_SQUARE*);
public:
};
/*--------------------------------------------------------------------------*/
class MODEL_BUILT_IN_SQUARE
  :public MODEL_CARD{
protected:
  explicit MODEL_BUILT_IN_SQUARE(const MODEL_BUILT_IN_SQUARE& p);
public:
  explicit MODEL_BUILT_IN_SQUARE(const BASE_SUBCKT*);
  ~MODEL_BUILT_IN_SQUARE() {--_count;}
public: // override virtual
  std::string dev_type()const;
  void      set_dev_type(const std::string& nt);
  CARD*     clone()const {return new MODEL_BUILT_IN_SQUARE(*this);}
  void      precalc_first();
  void      precalc_last();
  SDP_CARD* new_sdp(COMMON_COMPONENT* c)const;
  void      set_param_by_index(int, std::string&, int);
  bool      param_is_printable(int)const;
  std::string param_name(int)const;
  std::string param_name(int,int)const;
  std::string param_value(int)const;
  int param_count()const {return (1);}
  bool      is_valid(const COMPONENT*)const;
  void      tr_eval(COMPONENT*)const;
public: // not virtual
  static int count() {return _count;}
private: // strictly internal
  static int _count;
public: // input parameters
public: // calculated parameters
};
/*--------------------------------------------------------------------------*/
class COMMON_BUILT_IN_SQUARE
  :public COMMON_COMPONENT{
public:
  explicit COMMON_BUILT_IN_SQUARE(const COMMON_BUILT_IN_SQUARE& p);
  explicit COMMON_BUILT_IN_SQUARE(int c=0);
           ~COMMON_BUILT_IN_SQUARE();
  bool     operator==(const COMMON_COMPONENT&)const;
  COMMON_COMPONENT* clone()const {return new COMMON_BUILT_IN_SQUARE(*this);}
  void     set_param_by_index(int, std::string&, int);
  bool     param_is_printable(int)const;
  std::string param_name(int)const;
  std::string param_name(int,int)const;
  std::string param_value(int)const;
  int param_count()const {return (1 + COMMON_COMPONENT::param_count());}
  void     precalc_first(const CARD_LIST*);
  void     expand(const COMPONENT*);
  void     precalc_last(const CARD_LIST*);
  std::string name()const {itested();return "square";}
  const SDP_CARD* sdp()const {return _sdp;}
  bool     has_sdp()const {untested();return _sdp;}
  static int  count() {return _count;}
private: // strictly internal
  static int _count;
public: // input parameters
  PARAMETER<double> area;	// area factor
public: // calculated parameters
  SDP_CARD* _sdp;
public: // attached commons
};
/*--------------------------------------------------------------------------*/
class EVAL_BUILT_IN_SQUARE_Yj : public COMMON_COMPONENT {
private:
  explicit EVAL_BUILT_IN_SQUARE_Yj(const EVAL_BUILT_IN_SQUARE_Yj& p)
    :COMMON_COMPONENT(p) {}
public:
  explicit EVAL_BUILT_IN_SQUARE_Yj(int c=0) :COMMON_COMPONENT(c) {}
  bool operator==(const COMMON_COMPONENT& x)const {return COMMON_COMPONENT::operator==(x);}
  COMMON_COMPONENT* clone()const {return new EVAL_BUILT_IN_SQUARE_Yj(*this);}
  std::string name()const {untested(); return "EVAL_BUILT_IN_SQUARE_Yj";}
  void tr_eval(ELEMENT*d)const;
  bool has_tr_eval()const {return true;}
  bool has_ac_eval()const {return false;}
};
/*--------------------------------------------------------------------------*/
class DEV_BUILT_IN_SQUARE : public BASE_SUBCKT {
private:
  explicit DEV_BUILT_IN_SQUARE(const DEV_BUILT_IN_SQUARE& p);
public:
  explicit DEV_BUILT_IN_SQUARE();
           ~DEV_BUILT_IN_SQUARE() {--_count;}
private: // override virtual
  char      id_letter()const     {untested();return 'A';}
  bool      print_type_in_spice()const {return true;}
  std::string value_name()const  {return "area";}
  //std::string dev_type()const;   //BASE_SUBCKT
  int       max_nodes()const     {return 2;}
  int       min_nodes()const     {return 2;}
  //int     matrix_nodes()const; //BASE_SUBCKT
  int       net_nodes()const     {return 2;}
  int       int_nodes()const     {return 0;}
  CARD*     clone()const         {return new DEV_BUILT_IN_SQUARE(*this);}
  void      precalc_first() {COMPONENT::precalc_first(); if(subckt()) subckt()->precalc_first();}
  void      expand();
  void      precalc_last()  {COMPONENT::precalc_last(); assert(subckt()); subckt()->precalc_last();}
  //void    map_nodes();         //BASE_SUBCKT
  //void    tr_begin();          //BASE_SUBCKT
  //void    tr_restore();        //BASE_SUBCKT
  //void    dc_advance();        //BASE_SUBCKT
  //void    tr_advance();        //BASE_SUBCKT
  //void    tr_regress();        //BASE_SUBCKT
  //bool    tr_needs_eval()const;//BASE_SUBCKT
  //void    tr_queue_eval();     //BASE_SUBCKT
  //bool    do_tr();             //BASE_SUBCKT
  //void    tr_load();           //BASE_SUBCKT
  //double  tr_review();         //BASE_SUBCKT
  //void    tr_accept();         //BASE_SUBCKT
  //void    tr_unload();         //BASE_SUBCKT
  double    tr_probe_num(const std::string&)const;
  //void    ac_begin();          //BASE_SUBCKT
  //void    do_ac();             //BASE_SUBCKT
  //void    ac_load();           //BASE_SUBCKT
  //XPROBE  ac_probe_ext(CS&)const;//CKT_BASE/nothing
public:
  static int  count() {return _count;}
public: // may be used by models
private: // not available even to models
  static int _count;
public: // input parameters
public: // calculated parameters
public: // netlist
  COMPONENT* _Yj;
private: // node list
  enum {n_a, n_c};
  node_t _nodes[2];
  std::string port_name(int i)const {
    assert(i >= 0);
    assert(i < 2);
    static std::string names[] = {"a", "c", ""};
    return names[i];
  }
};
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
#endif
