/* $Id:$ 
 * d_square.model 
 * Copyright (C) 2011 Albert Davis
 * Author:   Gennadiy Serdyuk gserdyuk@gserdyuk.com
 *
 *------------------------------------------------------------------
 * i=ar*(v-v0)^2*signof(v-v0) + b model.
 * netlist syntax:
 * device:  Axxxx n+ n- mname Ar=<area>  v0 = <v0> b=<b>
 * model:   .model mname A
 * properties - singularity (di/dv=0) at v=v0
 */
/* This file is automatically generated. DO NOT EDIT */

#include "e_aux.h"
  static bool dummy=false;

#include "globals.h"
#include "e_elemnt.h"
#include "d_square_1.h"
/*--------------------------------------------------------------------------*/
const double NA(NOT_INPUT);
const double INF(BIGBIG);
/*--------------------------------------------------------------------------*/
int MODEL_BUILT_IN_SQUARE::_count = 0;
/*--------------------------------------------------------------------------*/
namespace MODEL_BUILT_IN_SQUARE_DISPATCHER { 
  static DEV_BUILT_IN_SQUARE p1d;
  static MODEL_BUILT_IN_SQUARE p1(&p1d);
  static DISPATCHER<MODEL_CARD>::INSTALL
    d1(&model_dispatcher, "A", &p1);
}
/*--------------------------------------------------------------------------*/
void SDP_BUILT_IN_SQUARE::init(const COMMON_COMPONENT* cc)
{
  assert(cc);
  SDP_CARD::init(cc);
}
/*--------------------------------------------------------------------------*/
TDP_BUILT_IN_SQUARE::TDP_BUILT_IN_SQUARE(const DEV_BUILT_IN_SQUARE*)
{
}
/*--------------------------------------------------------------------------*/
MODEL_BUILT_IN_SQUARE::MODEL_BUILT_IN_SQUARE(const BASE_SUBCKT* p)
  :MODEL_CARD(p)
{
  if (ENV::run_mode != rPRE_MAIN) {
    ++_count;
  }else{
  }
}
/*--------------------------------------------------------------------------*/
MODEL_BUILT_IN_SQUARE::MODEL_BUILT_IN_SQUARE(const MODEL_BUILT_IN_SQUARE& p)
  :MODEL_CARD(p)
{
  if (ENV::run_mode != rPRE_MAIN) {
    ++_count;
  }else{untested();//194
  }
}
/*--------------------------------------------------------------------------*/
std::string MODEL_BUILT_IN_SQUARE::dev_type()const
{
  if (dummy == true) {
    return "A";
  }else{untested();//235
    return MODEL_CARD::dev_type();
  }
}
/*--------------------------------------------------------------------------*/
void MODEL_BUILT_IN_SQUARE::set_dev_type(const std::string& new_type)
{
  if (Umatch(new_type, "A ")) {
    dummy = true;
  }else{
    MODEL_CARD::set_dev_type(new_type);
  }
}
/*--------------------------------------------------------------------------*/
void MODEL_BUILT_IN_SQUARE::precalc_first()
{
    const CARD_LIST* par_scope = scope();
    assert(par_scope);
    MODEL_CARD::precalc_first();
    // final adjust: code_pre
    // final adjust: override
    // final adjust: raw
    // final adjust: mid
    // final adjust: calculated
    // final adjust: post
    // final adjust: done
}
/*--------------------------------------------------------------------------*/
void MODEL_BUILT_IN_SQUARE::precalc_last()
{
    MODEL_CARD::precalc_last();
}
/*--------------------------------------------------------------------------*/
SDP_CARD* MODEL_BUILT_IN_SQUARE::new_sdp(COMMON_COMPONENT* c)const
{
  assert(c);
  if (COMMON_BUILT_IN_SQUARE* cc = dynamic_cast<COMMON_BUILT_IN_SQUARE*>(c)) {
    if (cc->_sdp) {
      cc->_sdp->init(cc);
      return cc->_sdp;
    }else{
      delete cc->_sdp;
      return new SDP_BUILT_IN_SQUARE(c);
    }
  }else{
    return MODEL_CARD::new_sdp(c);
  }
}
/*--------------------------------------------------------------------------*/
void MODEL_BUILT_IN_SQUARE::set_param_by_index(int i, std::string& value, int offset)
{
  switch (MODEL_BUILT_IN_SQUARE::param_count() - 1 - i) {
  case 0: untested(); break;
  default: throw Exception_Too_Many(i, 0, offset); break;
  }
}
/*--------------------------------------------------------------------------*/
bool MODEL_BUILT_IN_SQUARE::param_is_printable(int i)const
{
  switch (MODEL_BUILT_IN_SQUARE::param_count() - 1 - i) {
  case 0:  return (false);
  default: return false;
  }
}
/*--------------------------------------------------------------------------*/
std::string MODEL_BUILT_IN_SQUARE::param_name(int i)const
{
  switch (MODEL_BUILT_IN_SQUARE::param_count() - 1 - i) {
  case 0:  return "=====";
  default: return "";
  }
}
/*--------------------------------------------------------------------------*/
std::string MODEL_BUILT_IN_SQUARE::param_name(int i, int j)const
{
  if (j == 0) {
    return param_name(i);
  }else if (j == 1) {
    switch (MODEL_BUILT_IN_SQUARE::param_count() - 1 - i) {
    case 0:  return "";
    default: return "";
    }
  }else{
    return "";
  }
}
/*--------------------------------------------------------------------------*/
std::string MODEL_BUILT_IN_SQUARE::param_value(int i)const
{
  switch (MODEL_BUILT_IN_SQUARE::param_count() - 1 - i) {
  case 0:  unreachable(); return "";
  default: return "";
  }
}
/*--------------------------------------------------------------------------*/
bool MODEL_BUILT_IN_SQUARE::is_valid(const COMPONENT* d)const
{
  assert(d);
  return MODEL_CARD::is_valid(d);
}
/*--------------------------------------------------------------------------*/
void MODEL_BUILT_IN_SQUARE::tr_eval(COMPONENT*)const
{untested();//425
}
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
int DEV_BUILT_IN_SQUARE::_count = -1;
int COMMON_BUILT_IN_SQUARE::_count = -1;
static COMMON_BUILT_IN_SQUARE Default_BUILT_IN_SQUARE(CC_STATIC);
/*--------------------------------------------------------------------------*/
COMMON_BUILT_IN_SQUARE::COMMON_BUILT_IN_SQUARE(int c)
  :COMMON_COMPONENT(c),
   ar(1.0),
   b(-0.001),
   v0(1.0),
   _sdp(0)
{
  ++_count;
}
/*--------------------------------------------------------------------------*/
COMMON_BUILT_IN_SQUARE::COMMON_BUILT_IN_SQUARE(const COMMON_BUILT_IN_SQUARE& p)
  :COMMON_COMPONENT(p),
   ar(p.ar),
   b(p.b),
   v0(p.v0),
   _sdp(0)
{
  ++_count;
}
/*--------------------------------------------------------------------------*/
COMMON_BUILT_IN_SQUARE::~COMMON_BUILT_IN_SQUARE()
{
  --_count;
  delete _sdp;
}
/*--------------------------------------------------------------------------*/
bool COMMON_BUILT_IN_SQUARE::operator==(const COMMON_COMPONENT& x)const
{
  const COMMON_BUILT_IN_SQUARE* p = dynamic_cast<const COMMON_BUILT_IN_SQUARE*>(&x);
  return (p
    && ar == p->ar
    && b == p->b
    && v0 == p->v0
    && _sdp == p->_sdp
    && COMMON_COMPONENT::operator==(x));
}
/*--------------------------------------------------------------------------*/
void COMMON_BUILT_IN_SQUARE::set_param_by_index(int I, std::string& Value, int Offset)
{
  switch (COMMON_BUILT_IN_SQUARE::param_count() - 1 - I) {
  case 0:  ar = Value; break;
  case 1:  b = Value; break;
  case 2:  v0 = Value; break;
  default: COMMON_COMPONENT::set_param_by_index(I, Value, Offset);
  }
}
/*--------------------------------------------------------------------------*/
bool COMMON_BUILT_IN_SQUARE::param_is_printable(int i)const
{
  switch (COMMON_BUILT_IN_SQUARE::param_count() - 1 - i) {
  case 0:  return (true);
  case 1:  return (true);
  case 2:  return (true);
  default: return COMMON_COMPONENT::param_is_printable(i);
  }
}
/*--------------------------------------------------------------------------*/
std::string COMMON_BUILT_IN_SQUARE::param_name(int i)const
{
  switch (COMMON_BUILT_IN_SQUARE::param_count() - 1 - i) {
  case 0:  return "ar";
  case 1:  return "b";
  case 2:  return "v0";
  default: return COMMON_COMPONENT::param_name(i);
  }
}
/*--------------------------------------------------------------------------*/
std::string COMMON_BUILT_IN_SQUARE::param_name(int i, int j)const
{
  if (j == 0) {
    return param_name(i);
  }else if (j == 1) {
    switch (COMMON_BUILT_IN_SQUARE::param_count() - 1 - i) {
    case 0:  return "";
    case 1:  return "";
    case 2:  return "";
    default: return "";
    }
  }else{untested();//281
    return COMMON_COMPONENT::param_name(i, j);
  }
}
/*--------------------------------------------------------------------------*/
std::string COMMON_BUILT_IN_SQUARE::param_value(int i)const
{
  switch (COMMON_BUILT_IN_SQUARE::param_count() - 1 - i) {
  case 0:  return ar.string();
  case 1:  return b.string();
  case 2:  return v0.string();
  default: return COMMON_COMPONENT::param_value(i);
  }
}
/*--------------------------------------------------------------------------*/
void COMMON_BUILT_IN_SQUARE::expand(const COMPONENT* d)
{
  COMMON_COMPONENT::expand(d);
  attach_model(d);
  COMMON_BUILT_IN_SQUARE* c = this;
  const MODEL_BUILT_IN_SQUARE* m = dynamic_cast<const MODEL_BUILT_IN_SQUARE*>(model());
  if (!m) {
    throw Exception_Model_Type_Mismatch(d->long_label(), modelname(), "square");
  }else{
  }
  // size dependent
  //delete _sdp;
  _sdp = m->new_sdp(this);
  assert(_sdp);
  const SDP_BUILT_IN_SQUARE* s = prechecked_cast<const SDP_BUILT_IN_SQUARE*>(_sdp);
  assert(s);

  // subcircuit commons, recursive
  assert(c == this);
}
/*--------------------------------------------------------------------------*/
void COMMON_BUILT_IN_SQUARE::precalc_first(const CARD_LIST* par_scope)
{
  assert(par_scope);
  COMMON_COMPONENT::precalc_first(par_scope);
    e_val(&(this->ar), 1.0, par_scope);
    e_val(&(this->b), -0.001, par_scope);
    e_val(&(this->v0), 1.0, par_scope);
}
/*--------------------------------------------------------------------------*/
void COMMON_BUILT_IN_SQUARE::precalc_last(const CARD_LIST* par_scope)
{
  assert(par_scope);
  COMMON_COMPONENT::precalc_last(par_scope);
  COMMON_BUILT_IN_SQUARE* c = this;
  const MODEL_BUILT_IN_SQUARE* m = prechecked_cast<const MODEL_BUILT_IN_SQUARE*>(model());
    // final adjust: code_pre
    // final adjust: override
    // final adjust: raw
    e_val(&(this->ar), 1.0, par_scope);
    e_val(&(this->b), -0.001, par_scope);
    e_val(&(this->v0), 1.0, par_scope);
    // final adjust: mid
    // final adjust: calculated
    // final adjust: post
    // final adjust: done

  // size dependent
  //delete _sdp;
  _sdp = m->new_sdp(this);
  assert(_sdp);
  const SDP_BUILT_IN_SQUARE* s = prechecked_cast<const SDP_BUILT_IN_SQUARE*>(_sdp);
  assert(s);

  // subcircuit commons, recursive
  assert(c == this);
}
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
namespace DEV_BUILT_IN_SQUARE_DISPATCHER { 
  static DEV_BUILT_IN_SQUARE p0;
  static DISPATCHER<CARD>::INSTALL
    d0(&device_dispatcher, "A|square", &p0);
}
/*--------------------------------------------------------------------------*/
static EVAL_BUILT_IN_SQUARE_Yj Eval_Yj(CC_STATIC);
void EVAL_BUILT_IN_SQUARE_Yj::tr_eval(ELEMENT* d)const
{
  assert(d);
  DEV_BUILT_IN_SQUARE* p = prechecked_cast<DEV_BUILT_IN_SQUARE*>(d->owner());
  assert(p);
  const COMMON_BUILT_IN_SQUARE* c = prechecked_cast<const COMMON_BUILT_IN_SQUARE*>(p->common());
  assert(c);
  const SDP_BUILT_IN_SQUARE* s = prechecked_cast<const SDP_BUILT_IN_SQUARE*>(c->sdp());
  assert(s);
  const MODEL_BUILT_IN_SQUARE* m = prechecked_cast<const MODEL_BUILT_IN_SQUARE*>(c->model());
  assert(m);
   // ar*(v-v0)^2 + b
    FPOLY1& y = d->_y[0];
    double volts = y.x;
    double amps  = y.f0;
    trace2(d->long_label().c_str(), volts, amps);

    double polarity= (volts-c->v0)>=0?1:-1;
    
	y.f1 = polarity*2*  c->ar    *(volts-c->v0);
	y.f0 = polarity*    c->ar    *(volts-c->v0)*(volts-c->v0) + c->b;

}
/*--------------------------------------------------------------------------*/
DEV_BUILT_IN_SQUARE::DEV_BUILT_IN_SQUARE()
  :BASE_SUBCKT(),
   // input parameters,
   // calculated parameters,
   // netlist,
   _Yj(0)
{
  _n = _nodes;
  attach_common(&Default_BUILT_IN_SQUARE);
  ++_count;
  // overrides
}
/*--------------------------------------------------------------------------*/
DEV_BUILT_IN_SQUARE::DEV_BUILT_IN_SQUARE(const DEV_BUILT_IN_SQUARE& p)
  :BASE_SUBCKT(p),
   // input parameters,
   // calculated parameters,
   // netlist,
   _Yj(0)
{
  _n = _nodes;
  for (int ii = 0; ii < max_nodes() + int_nodes(); ++ii) {
    _n[ii] = p._n[ii];
  }
  ++_count;
  // overrides
}
/*--------------------------------------------------------------------------*/
void DEV_BUILT_IN_SQUARE::expand()
{
  BASE_SUBCKT::expand(); // calls common->expand, attached model
  assert(_n);
  assert(common());
  const COMMON_BUILT_IN_SQUARE* c = static_cast<const COMMON_BUILT_IN_SQUARE*>(common());
  assert(c);
  assert(c->model());
  const MODEL_BUILT_IN_SQUARE* m = prechecked_cast<const MODEL_BUILT_IN_SQUARE*>(c->model());
  assert(m);
  assert(c->sdp());
  const SDP_BUILT_IN_SQUARE* s = prechecked_cast<const SDP_BUILT_IN_SQUARE*>(c->sdp());
  assert(s);
  if (!subckt()) {
    new_subckt();
  }else{
  }

  if (_sim->is_first_expand()) {
    precalc_first();
    precalc_last();
    // local nodes

    // clone subckt elements
    {
      if (!_Yj) {
        const CARD* p = device_dispatcher["admittance"];
        assert(p);
        _Yj = dynamic_cast<COMPONENT*>(p->clone());
        assert(_Yj);
        subckt()->push_front(_Yj);
      }else{
      }
      {
        node_t nodes[] = {_n[n_a], _n[n_c]};
      _Yj->set_parameters("Yj", this, &Eval_Yj, 0., 0, NULL, 2, nodes);
      }
    }
  }else{
    //precalc();
  }
  //precalc();
  subckt()->expand();
  //subckt()->precalc();
  assert(!is_constant());
}
/*--------------------------------------------------------------------------*/
double DEV_BUILT_IN_SQUARE::tr_probe_num(const std::string& x)const
{
  assert(_n);
  const COMMON_BUILT_IN_SQUARE* c = prechecked_cast<const COMMON_BUILT_IN_SQUARE*>(common());
  assert(c);
  const MODEL_BUILT_IN_SQUARE* m = prechecked_cast<const MODEL_BUILT_IN_SQUARE*>(c->model());
  assert(m);
  const SDP_BUILT_IN_SQUARE* s = prechecked_cast<const SDP_BUILT_IN_SQUARE*>(c->sdp());
  assert(s);

  if (Umatch(x, "v{d} ")) {
    return  _n[n_a].v0() - _n[n_c].v0();
  }else if (Umatch(x, "i{d} ")) {
    return  CARD::probe(_Yj,"I");
  }else if (Umatch(x, "ij ")) {
    return  CARD::probe(_Yj,"I");
  }else {
    return BASE_SUBCKT::tr_probe_num(x);
  }
}
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
